---
name: skill-creator
description: Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Agent's capabilities with specialized knowledge, workflows, or tool integrations.
license: Complete terms in LICENSE.txt
---

# 技能创建者 (Skill Creator)

本技能提供创建高效技能的指导。

## 关于技能 (About Skills)

技能是模块化、自包含的软件包，通过提供专业知识、工作流和工具来扩展 Agent 的能力。将它们视为特定领域或任务的“入职指南”——它们将 Agent 从一个通用型智能体转变为一个配备了任何模型都无法完全具备的程序性知识的专业型智能体。

### 技能提供的内容

1. **专业工作流** - 针对特定领域的多个步骤的程序。
2. **工具集成** - 处理特定文件格式或 API 的指令。
3. **领域专业知识** - 公司特有的知识、模式（schemas）、业务逻辑。
4. **捆绑资源** - 用于复杂且重复性任务的脚本、参考资料和资源。

## 核心原则 (Core Principles)

### 简洁是关键 (Concise is Key)

上下文窗口是一种公共资源。技能与 Agent 所需的其他内容共享上下文窗口：系统提示词、对话历史、其他技能的元数据以及实际的用户请求。

**默认假设：Agent 已经非常聪明。** 只添加 Agent 尚未掌握的内容。挑战每一条信息： “Agent 真的需要这个解释吗？” 以及 “这段文字值得消耗这些 token 吗？”

优先使用简洁的示例，而不是冗长的解释。

### 设置适当的自由度 (Set Appropriate Degrees of Freedom)

根据任务的脆弱性和变异性来匹配详细程度：

**高自由度（基于文本的指令）：** 当多种方法都有效、决策依赖于上下文或启发式方法引导流程时使用。

**中等自由度（带参数的伪代码或脚本）：** 当存在首选模式、允许某些变化或配置会影响行为时使用。

**低自由度（特定的脚本，极少参数）：** 当操作脆弱且容易出错、一致性至关重要或必须遵循特定顺序时使用。

将 Agent 想象成在路径上探索：狭窄的桥梁和悬崖需要特定的护栏（低自由度），而开阔的田野则允许许多路线（高自由度）。

### 技能的结构 (Anatomy of a Skill)

每个技能都包含一个必需的 `SKILL.md` 文件和可选的捆绑资源：

```
skill-name/
├── SKILL.md (必需)
│   ├── YAML 前置元数据 (必需)
│   │   ├── name: (必需)
│   │   └── description: (必需)
│   └── Markdown 指令 (必需)
└── 捆绑资源 (可选)
    ├── scripts/          - 可执行代码 (Python/Bash/等)
    ├── references/       - 旨在根据需要加载到上下文中的文档
    └── assets/           - 用于输出的文件（模板、图标、字体等）
```

#### SKILL.md (必需)

每个 `SKILL.md` 包含：

- **前置配置 (Frontmatter)** (YAML): 包含 `name` 和 `description` 字段。这些是 Agent 用来决定何时使用该技能的唯一字段，因此，清晰且全面地描述技能是什么以及何时应该使用它非常重要。
- **主体 (Body)** (Markdown): 使用该技能的指令和指导。仅在技能触发后加载（如果加载的话）。

#### 捆绑资源 (可选)

##### 脚本 (`scripts/`)

针对需要确定性可靠性或被重复重写的任务的可执行代码 (Python/Bash/等)。

- **何时包含：** 当同一段代码被重复重写或需要确定性可靠性时。
- **示例：** 用于 PDF 旋转任务的 `scripts/rotate_pdf.py`。
- **优点：** 节省 token、确定性，可以在不加载到上下文的情况下执行。
- **注意：** 脚本可能仍需 Agent 读取以进行补丁修改或特定环境的调整。

##### 参考资料 (`references/`)

旨在根据需要加载到上下文中以辅助 Agent 处理和思考的文档和参考材料。

- **何时包含：** 供 Agent 在工作时参考的文档。
- **示例：** 用于财务模式的 `references/finance.md`，用于公司 NDA 模板的 `references/mnda.md`，用于公司政策的 `references/policies.md`，用于 API 规范的 `references/api_docs.md`。
- **用例：** 数据库模式、API 文档、领域知识、公司政策、详细的工作流指南。
- **优点：** 保持 `SKILL.md` 精简，仅在 Agent 确定需要时才加载。
- **最佳实践：** 如果文件很大（>10k 字），请在 `SKILL.md` 中包含 grep 搜索模式。
- **避免重复：** 信息应该存在于 `SKILL.md` 或参考文件中，而不是两者都有。优先将详细信息放在参考文件中，除非它确实是技能的核心——这可以让 `SKILL.md` 保持精简，同时让信息可被发现，而不占用上下文窗口。在 `SKILL.md` 中仅保留基本的程序指令和工作流指导；将详细的参考资料、模式和示例移至参考文件。

##### 资产 (`assets/`)

不打算加载到上下文中，而是用于 Agent 产生的输出中的文件。

- **何时包含：** 当技能需要将在最终输出中使用的文件时。
- **示例：** 用于品牌资产的 `assets/logo.png`，用于 PowerPoint 模板的 `assets/slides.pptx`，用于 HTML/React 样板的 `assets/frontend-template/`，用于排版的 `assets/font.ttf`。
- **用例：** 模板、图像、图标、样板代码、字体、被复制或修改的示例文件。
- **优点：** 将输出资源与文档分离，使 Agent 能够使用文件而无需将其加载到上下文中。

#### 技能中不应包含的内容

一个技能应该只包含直接支持其功能的必要文件。不要创建无关的文档或辅助文件，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等。

该技能应仅包含 AI 智能体完成手头工作所需的信息。它不应包含有关创建过程的辅助背景、设置和测试程序、面向用户的文档等。创建额外的文档文件只会增加混乱和困惑。

### 渐进式披露设计原则 (Progressive Disclosure Design Principle)

技能使用三级加载系统来高效管理上下文：

1. **元数据 (name + description)** - 始终在上下文中（约 100 字）。
2. **SKILL.md 主体** - 当技能触发时（<5k 字）。
3. **捆绑资源** - 根据 Agent 的需要（无限制，因为脚本可以在不读取到上下文窗口的情况下执行）。

#### 渐进式披露模式

保持 `SKILL.md` 主体精简，字数控制在 500 行以内，以减少上下文膨胀。接近此限制时，将内容拆分为独立文件。将内容拆分到其他文件时，务必在 `SKILL.md` 中引用它们并清晰描述何时阅读它们，以确保技能的读者知道它们的存在以及何时使用它们。

**关键原则：** 当技能支持多种变体、框架或选项时，在 `SKILL.md` 中仅保留核心工作流和选择指南。将特定变体的详细信息（模式、示例、配置）移至单独的参考文件。

**模式 1：带参考资料的高级指南**

```markdown
# PDF 处理

## 快速开始

使用 pdfplumber 提取文本：
[代码示例]

## 高级功能

- **表单填充**：参见 [FORMS.md](FORMS.md) 获取完整指南
- **API 参考**：参见 [REFERENCE.md](REFERENCE.md) 获取所有方法
- **示例**：参见 [EXAMPLES.md](EXAMPLES.md) 获取常见模式
```

Agent 仅在需要时加载 `FORMS.md`、`REFERENCE.md` 或 `EXAMPLES.md`。

**模式 2：特定领域的组织**

对于具有多个领域的技能，按领域组织内容，以避免加载无关的上下文：

```
bigquery-skill/
├── SKILL.md (概览与导航)
└── reference/
    ├── finance.md (收入，账单指标)
    ├── sales.md (机会，管道)
    ├── product.md (API 使用情况，功能)
    └── marketing.md (营销活动，归因)
```

当用户询问销售指标时，Agent 仅读取 `sales.md`。

同样，对于支持多个框架或变体的技能，按变体组织：

```
cloud-deploy/
├── SKILL.md (工作流 + 供应商选择)
└── references/
    ├── aws.md (AWS 部署模式)
    ├── gcp.md (GCP 部署模式)
    └── azure.md (Azure 部署模式)
```

当用户选择 AWS 时，Agent 仅读取 `aws.md`。

**模式 3：条件性详情**

显示基础内容，链接到高级内容：

```markdown
# DOCX 处理

## 创建文档

对于新文档，使用 docx-js。参见 [DOCX-JS.md](DOCX-JS.md)。

## 编辑文档

对于简单的编辑，直接修改 XML。

**对于修订 (Tracked Changes)**：参见 [REDLINING.md](REDLINING.md)
**对于 OOXML 详情**：参见 [OOXML.md](OOXML.md)
```

Agent 仅在用户需要这些功能时才读取 `REDLINING.md` 或 `OOXML.md`。

**重要准则：**

- **避免深层嵌套引用** - 保持引用距离 `SKILL.md` 仅一层深度。所有参考文件应直接从 `SKILL.md` 链接。
- **结构化较长的参考文件** - 对于超过 100 行的文件，请在顶部包含目录，以便 Agent 在预览时可以看到全部范围。

## 技能创建流程 (Skill Creation Process)

技能创建涉及以下步骤：

1. 通过具体示例理解技能
2. 规划可重用的技能内容（脚本、参考资料、资产）
3. 初始化技能（运行 `init_skill.py`）
4. 编辑技能（实现资源并编写 `SKILL.md`）
5. 打包技能（运行 `package_skill.py`）
6. 根据实际使用情况进行迭代

按顺序遵循这些步骤，仅在有明确原因说明它们不适用时才跳过。

### 步骤 1：通过具体示例理解技能

仅在技能的使用模式已被清晰理解时才跳过此步骤。即使是在处理现有技能时，它也很有价值。

要创建一个高效的技能，需要清晰地理解该技能将如何被使用的具体示例。这种理解可以来自直接的用户示例，或者是经过用户反馈验证的生成的示例。

例如，在构建 `image-editor` 技能时，相关问题包括：

- “`image-editor` 技能应该支持哪些功能？编辑、旋转，还有别的吗？”
- “你能给出一些如何使用此技能的例子吗？”
- “我可以想象用户会问‘从这张照片中移除红眼’或‘旋转这张照片’。你还想象了哪些其他的使用场景？”
- “用户会说什么来触发这个技能？”

为了避免让用户感到不知所措，避免在一条消息中询问太多问题。从最重要的问题开始，并根据需要进行跟进，以提高效率。

当对技能应支持的功能有了清晰的认识时，结束此步骤。

### 步骤 2：规划可重用的技能内容

要将具体的示例转化为高效的技能，请通过以下方式分析每个示例：

1. 考虑如何从头开始执行该示例。
2. 确定在重复执行这些工作流时，哪些脚本、参考资料和资产会有所帮助。

示例：在构建 `pdf-editor` 技能来处理诸如“帮我旋转这个 PDF”之类的查询时，分析表明：

1. 旋转 PDF 每次都需要重写相同的代码。
2. 在技能中存储一个 `scripts/rotate_pdf.py` 脚本会很有帮助。

示例：在为“帮我构建一个待办事项应用”或“帮我构建一个仪表盘来跟踪我的步数”之类的查询设计 `frontend-webapp-builder` 技能时，分析表明：

1. 编写前端 web 应用每次都需要相同的 HTML/React 样板代码。
2. 在技能中存储一个包含样板 HTML/React 项目文件的 `assets/hello-world/` 模板会很有帮助。

示例：在构建 `big-query` 技能来处理诸如“今天有多少用户登录了？”之类的查询时，分析表明：

1. 查询 BigQuery 每次都需要重新发现表模式和关系。
2. 在技能中存储一个记录表模式的 `references/schema.md` 文件会很有帮助。

要确定技能的内容，请分析每个具体示例，创建要包含的可重用资源列表：脚本、参考资料和资产。

### 步骤 3：初始化技能

此时，是时候实际创建技能了。

仅当正在开发的技能已经存在，且需要迭代或打包时，才跳过此步骤。在这种情况下，继续下一步。

从头开始创建新技能时，请始终运行 `init_skill.py` 脚本。该脚本可以方便地生成一个新的模板技能目录，该目录自动包含技能所需的一切，使技能创建过程更加高效可靠。

用法：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

该脚本将：

- 在指定路径创建技能目录。
- 生成包含正确前置配置和 TODO 占位符的 `SKILL.md` 模板。
- 创建示例资源目录：`scripts/`、`references/` 和 `assets/`。
- 在每个目录中添加可以自定义或删除的示例文件。

初始化后，根据需要自定义或删除生成的 `SKILL.md` 和示例文件。

### 步骤 4：编辑技能

在编辑（新生成的或现有的）技能时，请记住，该技能是为另一个 Agent 实例使用的。包含对 Agent 有益且不显而易见的信息。考虑哪些程序性知识、领域特定的细节或可重用的资产将帮助另一个 Agent 实例更有效地执行这些任务。

#### 学习成熟的设计模式

根据技能的需求咨询这些有用的指南：

- **多步骤流程**：参见 `references/workflows.md` 获取顺序工作流和逻辑判断。
- **特定的输出格式或质量标准**：参见 `references/output-patterns.md` 获取模板和示例模式。

这些文件包含了设计高效技能的公认最佳实践。

#### 从可重用的技能内容开始

要开始实现，从上面确定的可重用资源开始：`scripts/`、`references/` 和 `assets/` 文件。请注意，此步骤可能需要用户输入。例如，在实现 `brand-guidelines` 技能时，用户可能需要提供要存储在 `assets/` 中的品牌资产或模板，或要存储在 `references/` 中的文档。

添加的脚本必须通过实际运行它们来测试，以确保没有错误且输出符合预期。如果有很多类似的脚本，只需要测试一个具有代表性的样本，以确保在平衡完成时间的同时确信它们都能工作。

删除任何技能不需要的示例文件和目录。初始化脚本在 `scripts/`、`references/` 和 `assets/` 中创建示例文件以演示结构，但大多数技能不需要全部这些文件。

#### 更新 SKILL.md

**编写指令：** 始终使用祈使句/不定式形式。

##### 前置配置 (Frontmatter)

编写包含 `name` 和 `description` 的 YAML 前置配置：

- `name`: 技能名称。
- `description`: 这是技能的主要触发机制，帮助 Agent 了解何时使用该技能。
  - 包含技能的功能以及何时使用它的特定触发因素/上下文。
  - 在此处包含所有“何时使用”信息 - 不要放在主体中。主体仅在触发后加载，因此主体中的“何时使用此技能”部分对 Agent 没有帮助。
  - `docx` 技能的描述示例：“全面的文档创建、编辑和分析，支持修订、评论、格式保留和文本提取。当 Agent 需要处理专业文档 (.docx 文件) 以进行以下操作时使用：(1) 创建新文档，(2) 修改或编辑内容，(3) 处理修订，(4) 添加评论，或任何其他文档任务。”

不要在 YAML 前置配置中包含任何其他字段。

##### 主体 (Body)

编写使用技能及其捆绑资源的指令。

### 步骤 5：打包技能

一旦技能开发完成，必须将其打包成一个可分发的 `.skill` 文件并分享给用户。打包过程首先会自动验证技能，以确保其符合所有要求：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可选的输出目录规范：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

打包脚本将：

1. **自动验证** 技能，检查：
   - YAML 前置配置格式和必需字段。
   - 技能命名规范和目录结构。
   - 描述的完整性和质量。
   - 文件组织和资源引用。

2. 如果验证通过，则 **打包** 技能，创建一个以该技能命名的 `.skill` 文件（例如 `my-skill.skill`），其中包含所有文件并保持正确的目录结构以供分发。`.skill` 文件是一个具有 `.skill` 扩展名的 zip 文件。

如果验证失败，脚本将报告错误并退出，而不创建软件包。修复任何验证错误并再次运行打包命令。

### 步骤 6：迭代

在测试技能后，用户可能会要求改进。这通常发生在刚使用完技能后，此时对技能的表现有新鲜的背景认知。

**迭代工作流：**

1. 在实际任务中使用技能。
2. 发现困难或效率低下的地方。
3. 确定应如何更新 `SKILL.md` 或捆绑资源。
4. 实施更改并再次测试。